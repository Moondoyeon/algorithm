<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(test) {
        // 이 문제 풀때 중요한건, 완전탐색을 해야만 하는 문제인지 알아채는것 -> 해야한다면 4*4의 요소 하나 당 테스트 배열을 검사해야한다는 것

        // i, j = 학생번호
        // 바깥 이중 포문(i,j) : (1,1)(1,2) ~ (4,3)(4,4) : 멘토멘티 경우의 수 : 16번
        // 내부 이중 포문(k,s) : (0,0)(0,1) ~ (2,1)(2,2) : test배열 검사 : 12번

        // 멘토멘티 경우의수 한개 당 - 내부 포문(12번)을 돌린다.
        // ex) 멘토멘티 (3,1) 이라면
        // 내부 포문의 if문은
        // [3,4,1,2]와 비교한다. (3 === 3) (3 === 1) / (4 === 3) (4 === 1) / (1 === 3) (1 === 1) / (2 === 3) (2 === 1)
        // [4,3,2,1]와 비교한다. (4 === 3) (4 === 1) / (3 === 3) (3 === 1) / (2 === 3) (2 === 1) / (1 === 3) (1 === 1)
        // [3,1,4,2]와 비교한다. (3 === 3) (3 === 1) / (1 === 3) (1 === 1) / (4 === 3) (4 === 1) / (2 === 3) (2 === 1)

        // rankI = i학생의 등수 (0등,1등,2등,3등)

        let answer = 0,
          tmp = [];
        m = test.length;
        n = test[0].length;
        for (let i = 1; i <= n; i++) {
          for (let j = 1; j <= n; j++) {
            let count = 0;
            for (let k = 0; k < m; k++) {
              let rankI = (rankJ = 0);
              for (let s = 0; s < n; s++) {
                if (test[k][s] === i) rankI = s;
                if (test[k][s] === j) rankJ = s;
              }
              if (rankI < rankJ) count++; // 학생I가 J보다 높은 등수 횟수
            }
            if (count === m) {
              tmp.push([i, j]);
              answer++;
            }
          }
        }
        return answer;
      }
      let arr = [
        [3, 4, 1, 2],
        [4, 3, 2, 1],
        [3, 1, 4, 2],
      ];
      console.log(solution(arr));
    </script>
  </body>
</html>
